# 第1章 DDD入门



## 1. 为什么我们需要DDD

**提高沟通效率**：领域专家和开发者用统一的语言合作，确保软件准确反映业务规则，减少沟通误解。

**集中团队知识**：让每个人都学习和贡献业务知识，避免知识孤岛。

**明确业务重点**：通过战略设计，划分清晰的系统边界，优先处理关键业务问题。

**提升代码质量**：通过战术设计，写出可测试、易扩展的代码，保护业务规则不被破坏。



## 2. 项目是否值得做出DDD投入

DDD计分卡: 如果你的项目的情况在某行的描述范围之内,那么请在右边的列中记上相应的分数,最后将这些 分数相加得到总分。

**如果得分为7分或者以上,那么,应该考虑使用DDD了。**

| **情况描述**                                                 | **得分** | **备注**                                                     | **你的打分** |
| ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | ------------ |
| **如果你的软件完全以数据为中心, 所有操作都通过对数据库的CRUD完成** | 0        | 这似乎是一个傻瓜化的问题, 但是要分清简单和复杂的区别却不是那么容易的。并不是说只要不是纯粹的CRUD软件, 便可以采用DDD。因此我们需要采用另外的方法来判别简单和复杂。 |              |
| **如果你的系统只有25到30个业务操作**                         | 1        | 澄清一下, 我是说25到30个业务方法, 而不是说25到30个拥有多个方法的服务接口, 后者可能是复杂的。 |              |
| **当你的系统中有30到40个用户故事或者用例流时**               | 2        | 通常情况下, 复杂性并不能被及时发现, 我们开发者很容易低估软件的复杂性。我们希望使用Ruby on Rails来开发软件并不代表我们就必须使用Ruby on Rails, 而长远来看, 这是不利的。 |              |
| **即便我们的软件目前并不复杂, 但是之后呢?**                  | 3        | 这时我们有必要和领域专家一起探讨那些复杂的用例。 如果领域专家已经要求加入更复杂的功能，说明软件已经变得复杂，单纯的CRUD是不能满足需求。 如果领域专家认为既有的功能没什么可以探讨的，说明软件可能并不复杂。 |              |
| **软件的功能在接下来的几年里将不断变化, 而你并不能预期这些变化只是些简单的改变** | 4        | DDD可以帮助你管理软件的复杂性, 随着时间的推移, 你可以对软件模型进行重构。 |              |
| **你不了解软件所要处理的领域, 你的团队中也没有人曾经从事过该领域的开发工作** | 5        | 你需要和领域专家一起工作了。你肯定也在前面的计分行中打了分，采用DDD吧。 |              |



## 3. 贫血症和失忆症

#### 贫血对象

1. 你领域对象中，主要只有公有的 getter 和 setter 方法，而且几乎没有业务逻辑
2. 在你的系统中，有组件包含了大量的业务逻辑，而且这些业务逻辑只是通过调用这些 getter 和 setter 方法来实现



#### 为什么贫血对象（Anemic Domain Model）不好

贫血对象的坏处是，它把数据存储和业务逻辑分开，业务逻辑通常会被放到服务层中，导致代码变得难以维护和扩展。领域驱动设计提倡领域对象应该包含业务逻辑，成为模型的一部分，而不仅仅是数据的存储结构。



## 4. 如何DDD

在一个单一的领域模型（一个限界上下文内）使用通用语言。作为一个团队，我们可以自由地讨论什么样的模型才是最好的，通用语言达成一致之后着手开发

**注射流感疫苗模型 参考用例：**

| **可能的业务描述**                       | **生成的代码**                                               | **评价**                                                     |
| ---------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **“谁管呢?写代码就行了。”**              | `patient.setShotType(ShotTypes.TYPE_FLU);` `patient.setDose(dose);` `patient.setNurse(nurse);` | 差，直接操作数据，没有表达清晰的业务意图。                   |
| **“我们给病人注射流感疫苗。”**           | `patient.giveFluShot();`                                     | 好点了，但丢失了某些重要的概念，如谁给谁注射，剂量的确定等。 |
| **“护士给病人注射标准剂量的流感疫苗。”** | `Vaccine vaccine = vaccines.standardAdultFluDose();` `nurse.administerFluVaccine(patient, vaccine);` | 非常好，清晰地表达了业务意图，包含了关键的参与者和行为逻辑。 |



## 5. 使用DDD的业务价值

**1.你获得了一个非常有用的领域模型** 

将精力花在对业务最有价值的东西上，让核心域的优先级最高，更好地理解自己的任务所在

**2.你的业务得到了更准确的定义和理解** 

领域模型可以成为团队对业务的共同认知， 通用语言可以被广泛使用，可以通过讨论逐步发现隐藏的业务细节

**3.领域专家可以为软件设计做出贡献** 

领域专家可以通过提供知识帮助开发团队建模，避免“知识孤岛”，开发者离职导致知识流失。新人更快上手

**4.更好的用户体验** 

基于DDD设计的用户体验与业务逻辑高度一致，减少了用户理解的成本。软件本身可以自解释，无需过多培训

**5.清晰的模型边界** 
通过限界上下文明确团队的责任范围。职责明确，减少沟通成本

**6.更好的企业架构** 

上下文映射图展示了不同模型之间的依赖关系和协作方式。团队可以基于上下文划分职责，减少模块间的耦合。

**7.敏捷、迭代式和持续建模** 

领域模型是一个随业务需求变化而不断演化的工具。DDD并非追求模拟真实世界，而是聚焦于解决实际问题的“贴近真实的抽象”。它可以与敏捷开发完美结合，通过快速迭代不断优化模型。

**8.使用战略和战术新工具**

通过限界上下文划定边界，明确团队职责。使用上下文映射图处理上下文之间的集成。 战术层面：提供具体的建模工具，如聚合（Aggregate）、实体（Entity）、值对象（Value Object）、领域服务（Domain Service）、领域事件（Domain Event）等，用于解决具体的设计问题。



